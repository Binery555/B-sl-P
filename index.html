<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Binance Futures Positions</title>
  <!-- Binance Plex Webfont -->
  <link href="https://db.onlinewebfonts.com/c/d05c19ccecf7003d248c60ffd6b5e8f7?family=Binance+PLEX" rel="stylesheet"/>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"/>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --panel-bg: #1e2127;
      --secondary-bg: #32383e;
      --btn-bg: #2f3339;
      --text-primary: #ffffff;
      --text-secondary: #7c828a;
      --text-green: #3acf87;
      --text-red: #e04b4a;
      --highlight: #f0b90b;
    }
    body {
      background-color: var(--panel-bg);
      color: #b0b0b0;
      font-family: 'Binance PLEX', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex; flex-direction: column;
      height: 100vh; max-width: 430px; margin: 0 auto;
    }
    .header-wrapper { display: flex; justify-content: center; margin-top: 12px; margin-bottom: 4px; background: var(--panel-bg); }
    .header-toggle { display: flex; background: var(--panel-bg); border-radius: 6px; overflow: hidden; width: 180px; height: 28px; }
    .header-toggle button { flex: 1; padding: 4px 6px; border: none; background: transparent; color: var(--text-secondary); font-size: 11px; cursor: pointer; }
    .header-toggle .active { background: var(--secondary-bg); color: var(--text-primary); font-weight: 500; }

    nav.main-nav, .sub-toggle, .section-toggle { transform: translateX(0.1cm); }

    nav.main-nav { display: flex; margin: 0 12px; background: var(--panel-bg); padding: 4px 0; }
    nav.main-nav a { margin-right: 16px; text-decoration: none; color: var(--text-secondary); font-size: 13px; padding: 8px 0; white-space: nowrap; }
    nav.main-nav a.active { color: var(--text-primary); font-weight: 500; }

    .sub-toggle { display: flex; margin: 8px 12px; background: var(--panel-bg); padding: 4px; border-radius: 4px; }
    .sub-toggle button { margin-right: 8px; padding: 5px 10px; background: var(--panel-bg); border: none; border-radius: 4px; color: var(--text-secondary); font-size: 12px; cursor: pointer; }
    .sub-toggle .active { background: var(--secondary-bg); color: var(--text-primary); }

    .section-toggle { display: flex; margin: 12px; background: var(--panel-bg); padding: 4px; border-radius: 4px; }
    .section-toggle div { margin-right: 16px; cursor: pointer; font-size: 13px; position: relative; color: var(--text-secondary); }
    .section-toggle .active { color: var(--text-primary); font-weight: 500; }
    .section-toggle .active::after { content: ''; position: absolute; bottom: -4px; left: 50%; transform: translateX(-50%); width: 20px; height: 2px; background: var(--highlight); }

    .feed { display: flex; flex-direction: column; gap: 8px; flex: 1; overflow-y: auto; padding: 0 12px; margin-bottom: 4px; background: var(--panel-bg); }
    .feed::-webkit-scrollbar { display: none; }

    /* Profits cards: frames removed */
    .trade-panel { background: var(--panel-bg); padding: 12px; border-radius: 8px; border: none; box-shadow: none; }
    .trade-panel .header { display: flex; align-items: center; margin-bottom: 8px; }
    .icon-buy { background: var(--text-green); color: #fff; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 700; margin-right: 8px; border-radius: 2px; }
    .symbol { font-size: 14px; font-weight: 500; margin-right: 6px; color: var(--text-primary); }
    .tag { background: var(--secondary-bg); color: var(--text-secondary); font-size: 10px; padding: 1px 4px; margin-right: 4px; text-transform: uppercase; border-radius: 3px; }
    .exclamations { display: flex; margin-left: 6px; }
    .exclamations span { position: relative; width: 2px; height: 10px; background: var(--secondary-bg); margin: 0 1px; border-radius: 1px; transition: background 0.3s ease; }
    .exclamations span::after { content: ''; position: absolute; bottom: -3px; left: 50%; transform: translateX(-50%); width: 2px; height: 2px; background: inherit; border-radius: 50%; }
    .exclamations span.green, .exclamations span.green::after { background: var(--text-green); }
    .share { margin-left: auto; color: var(--text-secondary); font-size: 16px; cursor: pointer; }

    .content-columns { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 8px; gap: 8px; }
    .column { display: flex; flex-direction: column; }
    .column.right { text-align: right; }
    .stat { margin-bottom: 8px; }
    .label { font-size: 12px; color: var(--text-secondary); border-bottom: 1px dotted var(--text-secondary); padding-bottom: 2px; display: inline-block; }
    .label.no-line { border-bottom: none; }
    .value { font-size: 14px; font-weight: 400; color: var(--text-primary); transition: all 0.2s ease; }
    .value.green, .value.percent.green { color: var(--text-green); font-size: 18px; font-weight: 700; }
    .value.red, .value.percent.red { color: var(--text-red); font-size: 18px; font-weight: 700; }
    .margin-ratio-value { font-size: 12px !important; }

    .actions { display: flex; justify-content: space-between; gap: 8px; }
    .btn { flex: 1; background: var(--btn-bg); color: #fff; border: none; border-radius: 4px; padding: 6px 0; font-size: 12px; cursor: pointer; transition: background 0.3s; }
    .btn:hover { background: var(--secondary-bg); }
  </style>
</head>
<body>
  <div class="header-wrapper">
    <div class="header-toggle">
      <button class="active">Exchange</button>
      <button>Wallet</button>
    </div>
  </div>

  <nav class="main-nav">
    <a href="#" class="active">Overview</a>
    <a href="#">Funding</a>
    <a href="#futures">Futures</a>
    <a href="#">Spot</a>
  </nav>

  <div class="sub-toggle">
    <button class="active">USDⓈ-M</button>
    <button>COIN-M</button>
  </div>

  <div class="section-toggle">
    <div class="active">Positions</div>
    <div>Assets</div>
  </div>

  <div class="feed"></div>

  <script>
    // ---------------------- Symbols you want to render ----------------------
    const seedSymbols = [
      'BTCUSDT','ETHUSDT','BNBUSDT','ADAUSDT','SOLUSDT','XRPUSDT','DOTUSDT','LTCUSDT',
      'LINKUSDT','DOGEUSDT','AAVEUSDT','SUSHIUSDT','SHIBUSDT','COMPUSDT','ETCUSDT','ZECUSDT',
      'XMRUSDT','LRCUSDT','QNTUSDT','CRVUSDT','UNIUSDT','BCHUSDT','XLMUSDT','ATOMUSDT',
      'MATICUSDT','AVAXUSDT','TRXUSDT','EOSUSDT','NEARUSDT','FILUSDT',
      'OPUSDT','ARBUSDT','APTUSDT','SUIUSDT','INJUSDT','RNDRUSDT','FTMUSDT','GALAUSDT',
      'THETAUSDT','SANDUSDT','MANAUSDT','AXSUSDT','CFXUSDT','ICPUSDT','LDOUSDT','PEPEUSDT',
      'FLOKIUSDT','WIFUSDT','ARKUSDT','IOTAUSDT','KASUSDT','PYTHUSDT','STRKUSDT','JUPUSDT',
      'APEUSDT','BLURUSDT','SEIUSDT','TIAUSDT','TONUSDT','ONDOUSDT'
    ];

    // ---------------------- Utility: numbers & formatting ----------------------
    const numberWithCommas = (x) => String(x).replace(/\B(?=(\d{3})+(?!\d))/g, ',');

    const toFixedSafe = (n, dp) => {
      const num = Number(n);
      if (!Number.isFinite(num)) return (0).toFixed(dp);
      const m = Math.pow(10, dp);
      return (Math.round(num * m) / m).toFixed(dp);
    };

    const dpFromTick = (tickStr) => {
      const idx = (tickStr || '').indexOf('.');
      if (idx === -1) return 0;
      return tickStr.length - idx - 1;
    };

    const quantizeToTick = (price, tickSize) => {
      const step = parseFloat(tickSize);
      if (!isFinite(price) || !isFinite(step) || step <= 0) return price;
      return Math.round(price / step) * step;
    };

    const quantizeDownToStep = (qty, stepSize) => {
      const step = parseFloat(stepSize);
      if (!isFinite(qty) || !isFinite(step) || step <= 0) return qty;
      return Math.floor(qty / step) * step;
    };

    function joinIntDec(i, d) {
      const I = numberWithCommas(i);
      return d !== undefined ? I + '.' + d : I;
    }

    // ---------------------- Market meta (tick & step sizes) ----------------------
    const marketMeta = Object.create(null);
    async function loadExchangeMeta() {
      const url = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
      const res = await fetch(url);
      const json = await res.json();
      if (!json || !Array.isArray(json.symbols)) return;

      for (const s of json.symbols) {
        const sym = s.symbol;
        if (!seedSymbols.includes(sym)) continue;
        let tickSize = '0.01';
        let stepSize = '0.001';
        let minQty = 0;

        if (Array.isArray(s.filters)) {
          for (const f of s.filters) {
            if (f.filterType === 'PRICE_FILTER' && f.tickSize) tickSize = f.tickSize;
            if ((f.filterType === 'LOT_SIZE' || f.filterType === 'MARKET_LOT_SIZE') && f.stepSize) stepSize = f.stepSize;
            if ((f.filterType === 'LOT_SIZE' || f.filterType === 'MARKET_LOT_SIZE') && f.minQty) minQty = parseFloat(f.minQty) || 0;
          }
        }

        marketMeta[sym] = {
          tickSize,
          stepSize,
          minQty,
          priceDp: dpFromTick(tickSize)
        };
      }
    }

    const getMeta = (sym) => marketMeta[sym] || { tickSize: '0.01', stepSize: '0.001', minQty: 0, priceDp: 2 };

    function formatPrice(sym, x) {
      const m = getMeta(sym);
      const q = quantizeToTick(x, m.tickSize);
      const s = toFixedSafe(q, m.priceDp);
      const [i, d] = s.split('.');
      return joinIntDec(i, d);
    }

    // PNL must be EXACTLY 2 decimals globally
    function formatProfit(_sym, x) {
      const s = toFixedSafe(x, 2);
      const [i, d] = s.split('.');
      return joinIntDec(i, d);
    }

    function formatTwoDP(x) {
      const s = toFixedSafe(x, 2);
      const [i, d] = s.split('.');
      return joinIntDec(i, d);
    }

    // ---------------------- Maintenance Margin Rates (simple map) ----------------------
    const maintenanceMarginRates = {
      BTCUSDT: 0.004, ETHUSDT: 0.005, BNBUSDT: 0.005, ADAUSDT: 0.010, SOLUSDT: 0.008, XRPUSDT: 0.010,
      DOTUSDT: 0.010, LTCUSDT: 0.010, LINKUSDT: 0.010, DOGEUSDT: 0.012, AAVEUSDT: 0.010, SUSHIUSDT: 0.015,
      SHIBUSDT: 0.020, COMPUSDT: 0.010, ETCUSDT: 0.010, ZECUSDT: 0.015, XMRUSDT: 0.020, LRCUSDT: 0.020,
      QNTUSDT: 0.015, CRVUSDT: 0.020, UNIUSDT: 0.010, BCHUSDT: 0.010, XLMUSDT: 0.015, ATOMUSDT: 0.010,
      MATICUSDT: 0.010, AVAXUSDT: 0.010, TRXUSDT: 0.020, EOSUSDT: 0.015, NEARUSDT: 0.020, FILUSDT: 0.015,
      OPUSDT: 0.015, ARBUSDT: 0.020, APTUSDT: 0.015, SUIUSDT: 0.020, INJUSDT: 0.015, RNDRUSDT: 0.015,
      FTMUSDT: 0.020, GALAUSDT: 0.025, THETAUSDT: 0.020, SANDUSDT: 0.020, MANAUSDT: 0.020, AXSUSDT: 0.020,
      CFXUSDT: 0.025, ICPUSDT: 0.015, LDOUSDT: 0.020, PEPEUSDT: 0.030, FLOKIUSDT: 0.030, WIFUSDT: 0.030,
      ARKUSDT: 0.020, IOTAUSDT: 0.020, KASUSDT: 0.025, PYTHUSDT: 0.020, STRKUSDT: 0.020, JUPUSDT: 0.020,
      APEUSDT: 0.020, BLURUSDT: 0.020, SEIUSDT: 0.020, TIAUSDT: 0.020, TONUSDT: 0.015, ONDOUSDT: 0.020
    };
    const getMaintRate = (sym) => maintenanceMarginRates[sym] ?? 0.01;

    // ---------------------- Settings ----------------------
    let symbols = seedSymbols.slice();
    const allowedLeverages = [10, 20, 50, 100];
    const tradeCount = 40; // number of mock positions to render
    const feedDiv = document.querySelector('.feed');

    // ---------------------- Core calcs (Linear USDT, Cross, Long showcase) ----------------------
    const qtyFrom = (marginUsed, leverage, entry) => (leverage * marginUsed) / entry;          // opened qty (pre-quantize)
    const upnl = (mark, entry, qty) => (mark - entry) * qty;                                   // Unrealized PnL (USDT)
    const roiPct = (pnl, usedMargin) => (pnl / usedMargin) * 100;                              // ROI%
    const maintenance = (mmr, mark, qty) => mmr * mark * qty;                                  // Maintenance req (USDT)
    const marginBalance = (effectiveMargin, uPnL) => effectiveMargin + uPnL;                   // Equity bucket
    function liqPriceLong(entry, leverage, mmr, marginUsed, effectiveMargin) {
      // Simplified cross approximation using equity and MMR
      const Q = (leverage * marginUsed) / entry;
      const denom = Q * (1 - mmr);
      const num = Q * entry - effectiveMargin;
      if (denom <= 0) return null;
      const P = num / denom;
      if (!isFinite(P) || P <= 0) return null;
      return P;
    }
    const marginRatioPct = (maint, mBal) => (mBal <= 0 ? 100 : (maint / mBal) * 100);

    // ---------------------- UI helpers ----------------------
    const meterBars = () => {
      const totalBars = 4; const greenBars = Math.floor(Math.random() * totalBars) + 1;
      let html = '';
      for (let j = 0; j < totalBars; j++) html += `<span class="${j < greenBars ? 'green' : ''}"></span>`;
      return html;
    };

    // Build one trade panel element
    function createPanel({ sym, leverage, entry, mark, usedMargin, effMargin, mmr, qty, notionalUSDT }) {
      const pnl = upnl(mark, entry, qty);
      const roi = roiPct(pnl, usedMargin);
      const maint = maintenance(mmr, mark, qty);
      const mBal = marginBalance(effMargin, pnl);
      const mRatio = marginRatioPct(maint, mBal);
      const liq = liqPriceLong(entry, leverage, mmr, usedMargin, effMargin);

      const panel = document.createElement('div');
      panel.className = 'trade-panel';
      panel.innerHTML = `
        <div class="header">
          <span class="icon-buy">B</span>
          <span class="symbol">${sym}</span>
          <span class="tag">PERP</span>
          <span class="tag">Cross ${leverage}×</span>
          <span class="exclamations">${meterBars()}</span>
          <i class="fas fa-share-alt share"></i>
        </div>
        <div class="content-columns">
          <div class="column">
            <div class="stat">
              <div class="label">PNL (USDT)</div>
              <div class="value pnl ${pnl < 0 ? 'red' : 'green'}">${formatProfit(sym, pnl)}</div>
            </div>
            <div class="stat">
              <div class="label">Size (USDT)</div>
              <div class="value size">${formatTwoDP(notionalUSDT)}</div>
            </div>
            <div class="stat">
              <div class="label">Entry Price (USDT)</div>
              <div class="value entry">${formatPrice(sym, entry)}</div>
            </div>
          </div>
          <div class="column center">
            <div class="stat">
              <div class="label no-line">Margin (USDT)</div>
              <div class="value margin">${formatTwoDP(usedMargin)}</div>
            </div>
            <div class="stat">
              <div class="label no-line">Mark Price (USDT)</div>
              <div class="value mark">${formatPrice(sym, mark)}</div>
            </div>
          </div>
          <div class="column right">
            <div class="stat">
              <div class="label">ROI</div>
              <div class="value percent roi ${roi < 0 ? 'red' : 'green'}">${(roi >= 0 ? '+' : '') + toFixedSafe(roi, 2)}%</div>
            </div>
            <div class="stat margin-ratio">
              <div class="label">Margin Ratio</div>
              <div class="value percent margin-ratio-value ${mRatio >= 80 ? 'red' : 'green'}">${toFixedSafe(mRatio, 2)}%</div>
            </div>
            <div class="stat">
              <div class="label no-line">Liq. Price (USDT)</div>
              <div class="value liq">${liq === null ? '—' : formatPrice(sym, liq)}</div>
            </div>
          </div>
        </div>
        <div class="actions">
          <button class="btn">Leverage</button>
          <button class="btn">TP/SL</button>
          <button class="btn">Close</button>
          <button class="btn">Reverse</button>
        </div>`;

      return { node: panel, sym, leverage, mmr, entry, usedMargin, effMargin, qty, mark };
    }

    // Recompute & render a trade object
    function renderTrade(t) {
      const pnl = upnl(t.mark, t.entry, t.qty);
      const roi = roiPct(pnl, t.usedMargin);
      const maintV = maintenance(t.mmr, t.mark, t.qty);
      const mBal = marginBalance(t.effMargin, pnl);
      const mRatio = marginRatioPct(maintV, mBal);
      const liq = liqPriceLong(t.entry, t.leverage, t.mmr, t.usedMargin, t.effMargin);

      const pnlEl = t.node.querySelector('.value.pnl');
      pnlEl.textContent = formatProfit(t.sym, pnl); // ALWAYS 2dp
      pnlEl.classList.toggle('green', pnl >= 0);
      pnlEl.classList.toggle('red', pnl < 0);

      t.node.querySelector('.value.mark').textContent = formatPrice(t.sym, t.mark);

      const roiEl = t.node.querySelector('.value.roi');
      roiEl.textContent = (roi >= 0 ? '+' : '') + toFixedSafe(roi, 2) + '%';
      roiEl.classList.toggle('green', roi >= 0);
      roiEl.classList.toggle('red', roi < 0);

      const mrEl = t.node.querySelector('.value.margin-ratio-value');
      mrEl.textContent = toFixedSafe(mRatio, 2) + '%';
      mrEl.classList.toggle('green', mRatio < 80);
      mrEl.classList.toggle('red', mRatio >= 80);

      const liqEl = t.node.querySelector('.value.liq');
      liqEl.textContent = (liq === null) ? '—' : formatPrice(t.sym, liq);
    }

    // ---------------------- Live init + speed-synced updates ----------------------
    const trades = [];

    async function seedWithFuturesMark() {
      await loadExchangeMeta();
      symbols = symbols.filter(s => !!marketMeta[s]);

      // Snapshot of current marks
      const url = 'https://fapi.binance.com/fapi/v1/premiumIndex';
      const res = await fetch(url);
      const arr = await res.json();
      const markMap = Object.create(null);
      arr.forEach(o => { if (o && o.symbol) markMap[o.symbol] = parseFloat(o.markPrice); });

      for (let i = 0; i < tradeCount; i++) {
        const sym = symbols[i % symbols.length];
        const liveMark = markMap[sym];
        if (!isFinite(liveMark)) continue;

        const leverage = allowedLeverages[Math.floor(Math.random() * allowedLeverages.length)];
        const usedMargin = 50 + Math.random() * 950; // 50-1000 USDT
        const entryRaw = liveMark * (0.96 + Math.random() * 0.04); // 96%-100%
        const entry = quantizeToTick(entryRaw, getMeta(sym).tickSize);

        const m = getMeta(sym);
        let qtyRaw = qtyFrom(usedMargin, leverage, entry);
        let qty = quantizeDownToStep(qtyRaw, m.stepSize);
        if (qty < m.minQty) qty = m.minQty;

        const notionalUSDT = entry * qty;
        const effMargin = usedMargin * (1.5 + Math.random() * 2.5);
        const mmr = getMaintRate(sym);

        const panelState = createPanel({
          sym, leverage, entry, mark: liveMark, usedMargin, effMargin, mmr,
          qty, notionalUSDT
        });
        trades.push(panelState);
        feedDiv.appendChild(panelState.node);
      }
    }

    function connectFuturesMarkWS() {
      const WS_URL = 'wss://fstream.binance.com/ws/!markPrice@arr';
      let ws = new WebSocket(WS_URL);

      ws.onopen = () => console.log('[WS] Connected to Futures mark price stream');

      ws.onmessage = (evt) => {
        let data;
        try { data = JSON.parse(evt.data); } catch { return; }
        if (!Array.isArray(data)) return;

        for (const o of data) {
          const sym = o.s;
          const priceStr = o.p; // mark price string
          if (!sym || priceStr === undefined) continue;
          const mp = parseFloat(priceStr);
          if (!isFinite(mp)) continue;

          for (const t of trades) {
            if (t.sym === sym) {
              t.mark = mp; // Binance’s live push speed/values
              renderTrade(t);
            }
          }
        }
      };

      ws.onclose = (e) => {
        console.warn('[WS] Closed. Reconnecting in 2s...', e.code, e.reason);
        setTimeout(connectFuturesMarkWS, 2000);
      };
      ws.onerror = (err) => {
        console.error('[WS] Error', err);
        try { ws.close(); } catch {}
      };
    }

    (async function init() {
      try {
        await seedWithFuturesMark(); // snapshot + proper precisions
        connectFuturesMarkWS();      // live at Binance speed
      } catch (e) {
        console.error('Init failed:', e);
      }
      // Expose for dev/patching if needed
      window.trades = trades;
    })();
  </script>
</body>
</html>
